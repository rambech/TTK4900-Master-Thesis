from pygame import Surface, image, transform
import numpy as np
from utils import R2D, N2S, N2S2D, D2L

# TODO: Add comments and descriptions
# TODO: Make maps that are autogenerated
#       Some ground rules:
#           - The map is always the same size
#           - The px/m scale is always the same
#           - The quay can vary in size
#           - The quay must be at the edges of the map
#           - The bounds are always at the edges of the map
# TODO: Add static obstacles that the boat has to dock in between,
#       use a new grey version of Target() for this
# TODO: Change colliding edge to be determined by which edge is closed to the center of the map
# TODO: Define all maps and obstacles in {n} then scale them


class Target():
    def __init__(self, eta_d: np.ndarray, L: float, B: float, scale: float, offset: float) -> None:
        """
        Displays and holds target pose properties

        Parameters
        ----------
        eta_d : np.ndarray
            Is the desired pose in {n} frame
        L : float
            Length of the vessel
        B : float
            Beam of the vessel
        scale: float
            Scaling to fit screen   [px/m]
        offset: float
            x, y distance from top left corner to the center
            of the game screen

        Attributes
        ----------
        image : pygame.image
            Visualisation of target pose
        rect : pygame.Rect
            Hitbox of the target pose
        eta_d : np.ndarray
            Desired pose in {n} frame
        """

        # Use screen coordinates for rendering
        eta_ds = N2S(eta_d, scale, offset)
        target_image = image.load(
            'vehicle/images/target.png')
        target_image = transform.scale(
            target_image, (scale*B, scale*L))
        self.image = transform.rotate(
            target_image, -R2D(eta_ds[-1]))

        center = (eta_ds[0], eta_ds[1])
        self.rect = self.image.get_rect(center=center)
        self.eta_d = eta_d.copy()  # Save desired pose


# class Wall():
#     def __init__(self, wall_width: float, wall_length: float, wall_pos: tuple[float, float], scale: float, origin: np.ndarray) -> None:
#         # xy_s = N2S2D(np.asarray(wall_pos), scale, origin)
#         new_array = np.array([wall_pos[0], wall_pos[1], 0, 0, 0, 0])
#         xy_s = N2S(new_array, scale, origin)
#         self.surf = Surface((wall_width*scale, wall_length*scale))
#         self.surf.fill((0, 0, 0))   # Black
#         self.rect = self.surf.get_rect(center=(xy_s[0], xy_s[1]))

#         # Vertices
#         NW = (wall_pos[0] - wall_width/2, wall_pos[1] - wall_length/2)
#         NE = (wall_pos[0] + wall_width/2, wall_pos[1] - wall_length/2)
#         SE = (wall_pos[0] + wall_width/2, wall_pos[1] + wall_length/2)
#         SW = (wall_pos[0] - wall_width/2, wall_pos[1] + wall_length/2)

#         # Edges
#         edges = [(NE, NW), (NE, SE), (SW, SE), (NW, SW)]

#         colliding_edge = edges[0]
#         # distance = np.inf
#         # for edge in edges:
#         #     if D2L(edge, origin[0:2])[1] < distance:
#         #         colliding_edge = edge

#         self.colliding_edge = colliding_edge

#         # Check which edge is closest to the origin
#         # match colliding_edge:
#         #     case "north":
#         #         self.colliding_edge = (NE, NW)
#         #     case "east":
#         #         self.colliding_edge = (NE, SE)
#         #     case "south":
#         #         self.colliding_edge = (SW, SE)
#         #     case "west":
#         #         self.colliding_edge = (NW, SW)
#         #     case _:
#         #         pass


class Map():
    # Map parameters
    BOX_WIDTH = 500     # [px]  Overall box width
    BOX_LENGTH = 500    # [px]  Overall box length/height
    WALL_THICKNESS = 2  # [m]   Border wall thickness
    scale = 30
    # [px, px, p] Screen offset
    origin = np.array([BOX_WIDTH/2, BOX_LENGTH/2, 0], float)
    MAP_SIZE = (30, 30)                 # [m]    Size of map

    def __init__(self) -> None:
        # # Placements of border wall
        # north_wall_pos = (self.MAP_SIZE[0]/2, 0 + (self.WALL_THICKNESS/2))
        # south_wall_pos = (self.MAP_SIZE[0]/2, self.MAP_SIZE[1] -
        #                   (self.WALL_THICKNESS/2))
        # east_wall_pos = (self.MAP_SIZE[0] -
        #                  (self.WALL_THICKNESS/2), self.MAP_SIZE[1]/2)
        # west_wall_pos = (0 + (self.WALL_THICKNESS/2), self.MAP_SIZE[1]/2)

        # # Instantiation of walls
        # north_wall = Wall(
        #     self.MAP_SIZE[0], self.WALL_THICKNESS, north_wall_pos, self.scale, self.origin)
        # south_wall = Wall(
        #     self.MAP_SIZE[0], self.WALL_THICKNESS, south_wall_pos, self.scale, self.origin)
        # east_wall = Wall(self.WALL_THICKNESS,
        #                  self.MAP_SIZE[1], east_wall_pos, self.scale, self.origin)
        # west_wall = Wall(self.WALL_THICKNESS,
        #                  self.MAP_SIZE[1], west_wall_pos, self.scale, self.origin)

        # # Make obstacle list with the walls
        # self.obstacles = [north_wall, south_wall, east_wall, west_wall]
        pass
